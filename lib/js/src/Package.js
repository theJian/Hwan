// Generated by BUCKLESCRIPT VERSION 2.2.3, PLEASE EDIT WITH CARE
'use strict';

var Fs = require("fs");
var Json = require("@glennsl/bs-json/lib/js/src/Json.bs.js");
var List = require("bs-platform/lib/js/list.js");
var Path = require("path");
var $$Array = require("bs-platform/lib/js/array.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Hashtbl = require("bs-platform/lib/js/hashtbl.js");
var Js_dict = require("bs-platform/lib/js/js_dict.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Config$Hwan = require("./Config.js");
var Json_decode = require("@glennsl/bs-json/lib/js/src/Json_decode.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function hashtbl2pairlist(param) {
  if (param) {
    return $$Array.to_list(Js_dict.entries(param[0]));
  } else {
    return /* [] */0;
  }
}

function decodeDependencies(json) {
  return List.flatten(List.map(hashtbl2pairlist, /* :: */[
                  Json_decode.optional((function (param) {
                          return Json_decode.field("dependencies", (function (param) {
                                        return Json_decode.dict(Json_decode.string, param);
                                      }), param);
                        }), json),
                  /* :: */[
                    Json_decode.optional((function (param) {
                            return Json_decode.field("devDependencies", (function (param) {
                                          return Json_decode.dict(Json_decode.string, param);
                                        }), param);
                          }), json),
                    /* :: */[
                      Json_decode.optional((function (param) {
                              return Json_decode.field("peerDependencies", (function (param) {
                                            return Json_decode.dict(Json_decode.string, param);
                                          }), param);
                            }), json),
                      /* :: */[
                        Json_decode.optional((function (param) {
                                return Json_decode.field("bundledDependencies", (function (param) {
                                              return Json_decode.dict(Json_decode.string, param);
                                            }), param);
                              }), json),
                        /* :: */[
                          Json_decode.optional((function (param) {
                                  return Json_decode.field("optionalDependencies", (function (param) {
                                                return Json_decode.dict(Json_decode.string, param);
                                              }), param);
                                }), json),
                          /* [] */0
                        ]
                      ]
                    ]
                  ]
                ]));
}

function decodePackageJson(json) {
  return /* record */[
          /* name */Json_decode.optional((function (param) {
                  return Json_decode.field("name", Json_decode.string, param);
                }), json),
          /* version */Json_decode.optional((function (param) {
                  return Json_decode.field("version", Json_decode.string, param);
                }), json),
          /* scripts */hashtbl2pairlist(Json_decode.optional((function (param) {
                      return Json_decode.field("scripts", (function (param) {
                                    return Json_decode.dict(Json_decode.string, param);
                                  }), param);
                    }), json)),
          /* deps */decodeDependencies(json)
        ];
}

function readPackageMeta(path) {
  return decodePackageJson(Json.parseOrRaise(Fs.readFileSync(Path.join(path, Config$Hwan.packageJson), "utf8")));
}

function concretizePackage(path) {
  var match = +Fs.existsSync(Path.join(path, Config$Hwan.packageJson));
  if (match !== 0) {
    return /* Some */[/* record */[
              /* path */path,
              /* meta */readPackageMeta(path)
            ]];
  } else {
    return /* None */0;
  }
}

function buildPNode(pkgIdx, $$package) {
  return /* record */[
          /* package */$$package,
          /* depNodes */List.fold_left((function (localDeps, dep) {
                  var exit = 0;
                  var idx;
                  try {
                    idx = Hashtbl.find(pkgIdx, dep);
                    exit = 1;
                  }
                  catch (exn){
                    if (exn === Caml_builtin_exceptions.not_found) {
                      return localDeps;
                    } else {
                      throw exn;
                    }
                  }
                  if (exit === 1) {
                    return /* :: */[
                            idx,
                            localDeps
                          ];
                  }
                  
                }), /* [] */0, List.split($$package[/* meta */1][/* deps */3])[0])
        ];
}

function buildPackageGraph(packages) {
  var size = packages.length;
  var pkgIdx = Hashtbl.create(/* None */0, size);
  $$Array.iteri((function (idx, pkg) {
          var match = pkg[/* meta */1][/* name */0];
          if (match) {
            return Hashtbl.add(pkgIdx, match[0], idx);
          } else {
            return /* () */0;
          }
        }), packages);
  return $$Array.map((function (param) {
                return buildPNode(pkgIdx, param);
              }), packages);
}

function findRootPNodes(graph) {
  return List.filter((function (param) {
                  if (param) {
                    return /* false */0;
                  } else {
                    return /* true */1;
                  }
                }))($$Array.to_list(graph));
}

function findLeftPNodeIds(graph) {
  var isLeft = Caml_array.caml_make_vect(graph.length, /* true */1);
  return List.filter((function (id) {
                  return +(id !== -1);
                }))(List.mapi((function (idx, isLeft) {
                    if (isLeft !== 0) {
                      return idx;
                    } else {
                      return -1;
                    }
                  }), $$Array.to_list(List.fold_left((function (a, idx) {
                            Caml_array.caml_array_set(a, idx, /* false */0);
                            return a;
                          }), isLeft, List.flatten($$Array.to_list($$Array.map((function (node) {
                                        return node[/* depNodes */1];
                                      }), graph)))))));
}

function findNodeId(f, graph) {
  return List.hd(List.filter((function (param) {
                      return Caml_obj.caml_notequal(-1, param);
                    }))($$Array.to_list($$Array.mapi((function (idx, node) {
                            var match = Curry._1(f, node);
                            if (match !== 0) {
                              return idx;
                            } else {
                              return -1;
                            }
                          }), graph))));
}

exports.hashtbl2pairlist = hashtbl2pairlist;
exports.decodeDependencies = decodeDependencies;
exports.decodePackageJson = decodePackageJson;
exports.readPackageMeta = readPackageMeta;
exports.concretizePackage = concretizePackage;
exports.buildPNode = buildPNode;
exports.buildPackageGraph = buildPackageGraph;
exports.findRootPNodes = findRootPNodes;
exports.findLeftPNodeIds = findLeftPNodeIds;
exports.findNodeId = findNodeId;
/* fs Not a pure module */
