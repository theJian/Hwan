// Generated by BUCKLESCRIPT VERSION 2.2.3, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Path = require("path");
var $$Array = require("bs-platform/lib/js/array.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Js_option = require("bs-platform/lib/js/js_option.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Logging$Hwan = require("./Logging.js");
var Package$Hwan = require("./Package.js");
var Child_process = require("child_process");
var CollectPackages$Hwan = require("./CollectPackages.js");

var dirname = typeof (__dirname) === "undefined" ? undefined : (__dirname);

var dirname$1 = dirname === undefined ? /* None */0 : [dirname];

function readRootPackage() {
  return Package$Hwan.readPackageMeta(Path.join(Js_option.getExn(dirname$1), "../../../"));
}

function getVersion($$package) {
  var match = $$package[/* version */1];
  if (match) {
    return match[0];
  } else {
    return "";
  }
}

function echoVersion() {
  console.log(getVersion(readRootPackage(/* () */0)));
  return /* () */0;
}

function findStartNodeIds(name, graph) {
  if (name === "") {
    return Package$Hwan.findLeftPNodeIds(graph);
  } else {
    return /* :: */[
            Package$Hwan.findNodeId((function (node) {
                    var match = node[/* package */0][/* meta */1][/* name */0];
                    if (match) {
                      return +(match[0] === name);
                    } else {
                      return /* false */0;
                    }
                  }), graph),
            /* [] */0
          ];
  }
}

function queueTask(graph, startNodeIds, $staropt$star, _) {
  var exclude = $staropt$star ? $staropt$star[0] : /* [] */0;
  var nodeStatuses = Caml_array.caml_make_vect(graph.length, /* Nop */0);
  var dependents = List.fold_left((function (deps, param) {
          var id1 = param[0];
          Caml_array.caml_array_set(deps, id1, /* :: */[
                param[1],
                Caml_array.caml_array_get(deps, id1)
              ]);
          return deps;
        }), Caml_array.caml_make_vect(graph.length, /* [] */0), List.flatten(List.mapi((function (id1, node) {
                  return List.map((function (id2) {
                                return /* tuple */[
                                        id2,
                                        id1
                                      ];
                              }), node[/* depNodes */1]);
                }), $$Array.to_list(graph))));
  var que = [/* [] */0];
  var cur = List.map((function (id) {
          var match = List.exists((function (param) {
                  return Caml_obj.caml_equal(id, param);
                }), startNodeIds);
          if (match !== 0) {
            return /* tuple */[
                    id,
                    /* Include */1
                  ];
          } else {
            return /* tuple */[
                    id,
                    /* Exclude */2
                  ];
          }
        }), Package$Hwan.findLeftPNodeIds(graph));
  while(cur !== /* [] */0) {
    List.iter((function (param) {
            var status = param[1];
            var id = param[0];
            Caml_array.caml_array_set(nodeStatuses, id, status);
            if (status === /* Include */1 && !List.exists((function (param) {
                      return Caml_obj.caml_equal(id, param);
                    }), exclude)) {
              que[0] = /* :: */[
                id,
                que[0]
              ];
            }
            return /* () */0;
          }), cur);
    cur = List.filter((function (param) {
              if (param[1] !== 0) {
                return /* true */1;
              } else {
                return /* false */0;
              }
            }))(List.map((function (id) {
                var dependentStatuses = List.map((function (id) {
                        return Caml_array.caml_array_get(nodeStatuses, id);
                      }), Caml_array.caml_array_get(dependents, id));
                var status = List.exists((function (param) {
                        return Caml_obj.caml_equal(/* Nop */0, param);
                      }), dependentStatuses) ? /* Nop */0 : (
                    List.exists((function (param) {
                            return Caml_obj.caml_equal(/* Include */1, param);
                          }), dependentStatuses) ? /* Include */1 : /* Exclude */2
                  );
                return /* tuple */[
                        id,
                        status
                      ];
              }), List.sort_uniq(Caml_obj.caml_compare, List.flatten(List.map((function (param) {
                            return Caml_array.caml_array_get(graph, param[0])[/* depNodes */1];
                          }), cur)))));
  };
  return List.map((function (id) {
                return Caml_array.caml_array_get(graph, id);
              }), que[0]);
}

function syscall(syscmd, node) {
  var path = node[/* package */0][/* path */0];
  return Logging$Hwan.output(Child_process.execSync(syscmd, {
                  cwd: path,
                  encoding: "utf8"
                }));
}

function runCommand(command, options) {
  Logging$Hwan.logCommand(command);
  var match = +(options[/* package */2] === "");
  Logging$Hwan.logPackage(match !== 0 ? "all" : options[/* package */2]);
  var graph = Package$Hwan.buildPackageGraph(CollectPackages$Hwan.collectPackages(/* () */0));
  var startIds = findStartNodeIds(options[/* package */2], graph);
  var partial_arg = List.fold_left((function (s1, s2) {
          return s1 + (" " + s2);
        }), "", command);
  var match$1 = options[/* onlyDep */1];
  List.iter((function (param) {
          return syscall(partial_arg, param);
        }), queueTask(graph, startIds, /* Some */[match$1 !== 0 ? startIds : /* [] */0], /* () */0));
  return /* () */0;
}

function run(param) {
  var options = param[1];
  if (options[/* version */0] !== 0) {
    return echoVersion(/* () */0);
  } else {
    return runCommand(param[0], options);
  }
}

exports.dirname = dirname$1;
exports.readRootPackage = readRootPackage;
exports.getVersion = getVersion;
exports.echoVersion = echoVersion;
exports.findStartNodeIds = findStartNodeIds;
exports.queueTask = queueTask;
exports.syscall = syscall;
exports.runCommand = runCommand;
exports.run = run;
/* dirname Not a pure module */
